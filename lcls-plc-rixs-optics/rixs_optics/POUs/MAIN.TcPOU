<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="MAIN" Id="{21f3a158-4837-47ff-8ec7-29454a44967d}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	// M1K2
	// Motors
	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Yleft]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Yleft]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:MMS:YLEFT
	'}
	M1 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Yup
	fbMotionStage_m1 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Yright]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Yright]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:MMS:YRIGHT
	'}
	M2 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Ydwn
	fbMotionStage_m2 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Xup]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Xup]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:MMS:XUP
	'}
	M3 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Xup
	fbMotionStage_m3 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Xdwn]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Xdwn]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:MMS:XDWN
	'}
	M4 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Xdwn
	fbMotionStage_m4 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_PitchCoarse]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_M1K2_PitchCoarse]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:MMS:PITCH
	'}
	M5 : DUT_MotionStage := (fVelocity := 30.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Pitch Stepper

	{attribute 'TcLinkTo' := '.fbRunHOMS.bSTOEnable1:=TIIB[EL1004_M1K2_STO]^Channel 1^Input;
                              .fbRunHOMS.bSTOEnable2:=TIIB[EL1004_M1K2_STO]^Channel 2^Input;
	                          .fbRunHOMS.stYupEnc.Count:=TIIB[EL5042_M1K2_Yleftright]^FB Inputs Channel 1^Position;
	                          .fbRunHOMS.stYdwnEnc.Count:=TIIB[EL5042_M1K2_Yleftright]^FB Inputs Channel 2^Position;
	                          .fbRunHOMS.stXupEnc.Count:=TIIB[EL5042_M1K2_Xupdwn]^FB Inputs Channel 1^Position;
	                          .fbRunHOMS.stXdwnEnc.Count:=TIIB[EL5042_M1K2_Xupdwn]^FB Inputs Channel 2^Position'}
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH
	'}
	M1K2 : DUT_HOMS;

	// Encoder Arrays/RMS Watch:
	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:ENC:Y
	'}
	fbYRMSErrorM1K2 : FB_RMSWatch;
	fMaxYRMSErrorM1K2 : LREAL;
	fMinYRMSErrorM1K2 : LREAL;

	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:ENC:X
	'}
	fbXRMSErrorM1K2 : FB_RMSWatch;
	fMaxXRMSErrorM1K2 : LREAL;
	fMinXRMSErrorM1K2 : LREAL;

	{attribute 'pytmc' := '
		pv: MR1K2:SWITCH:ENC:PITCH
	'}
	fbPitchRMSErrorM1K2 : FB_RMSWatch;
	fMaxPitchRMSErrorM1K2 : LREAL;
	fMinPitchRMSErrorM1K2 : LREAL;

	// Pitch Control
	fbM1K2PitchControl : FB_PitchControl;
	bM1K2PitchDone : BOOL;
	bM1K2PitchBusy : BOOL;

	// 3-15-20 Having issues with pitch control on new Axilon systems
	// Using stepper only for now
	fbMotionStage_m5 : FB_MotionStage;
	
	// GM
	// Style modification of Axilon project to LCLSII Optics PLC conventions

	// STO
	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^Term 5 (EK1122)^EK1100_GM^EL1004_GM_STO^Channel 1^Input'}
	bGMSTO1 AT %I* : BOOL;
	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^Term 5 (EK1122)^EK1100_GM^EL1004_GM_STO^Channel 2^Input'}
	bGMSTO2 AT %I* : BOOL;

	// Motors
	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_GM_MRPI]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_GM_MRPI]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: GM:MMS:MRPI
	'}
	M6 : DUT_MotionStage := (fVelocity:=200.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // GM Mirror Pitch
	fbMotionStage_m6 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_GM_GRPI]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_GM_GRPI]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: GM:MMS:GRPI
	'}
	M7 : DUT_MotionStage := (fVelocity:=200.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // GM Grating Pitch
	fbMotionStage_m7 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_GM_MRX]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_GM_MRX]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: GM:MMS:MRX
	'}
	M8 : DUT_MotionStage := (fVelocity:=500.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // GM Mirror X
	fbMotionStage_m8 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_GM_GRX]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_GM_GRX]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: GM:MMS:GRX
	'}
	M9 : DUT_MotionStage := (fVelocity:=1000.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // GM Grating X
	fbMotionStage_m9 : FB_MotionStage;

	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_GM_SIO]^STM Status^Status^Digital input 1;
                              .bLimitBackwardEnable:=TIIB[EL7047_GM_SIO]^STM Status^Status^Digital input 2'}
	{attribute 'pytmc' := '
		pv: GM:MMS:SIO
	'}
	M10 : DUT_MotionStage := (fVelocity := 500.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // GM Screwdriver InOut
	fbMotionStage_m10 : FB_MotionStage;

	{attribute 'pytmc' := '
		pv: GM:MMS:SR
	'}
	M11 : DUT_MotionStage := (fVelocity := 500.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // GM Screwdriver Rotation
	fbMotionStage_m11 : FB_MotionStage;

	// FLOW and RTD Sensors
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 16 (EL3054)^AI Standard Channel 1^Value'}	
	flow_1 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 16 (EL3054)^AI Standard Channel 2^Value'}	
	flow_2 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 16 (EL3054)^AI Standard Channel 3^Value'}		
	pres_1 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 17 (EL3202-0010)^RTD Inputs Channel 1^Value'}		
	rtd_01 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 17 (EL3202-0010)^RTD Inputs Channel 1^Value'}		
	rtd_02 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 18 (EL3202-0010)^RTD Inputs Channel 2^Value'}		
	rtd_03 AT %I*: INT;	
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 18 (EL3202-0010)^RTD Inputs Channel 1^Value'}		
	rtd_04 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 19 (EL3204)^RTD Inputs Channel 2^Value'}		
	rtd_05 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 19 (EL3204)^RTD Inputs Channel 1^Value'}		
	rtd_06 AT %I*: INT;
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 20 (EL3204)^RTD Inputs Channel 2^Value'}		
	rtd_07 AT %I*: INT;	
	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 20 (EL3204)^RTD Inputs Channel 1^Value'}		
	rtd_08 AT %I*: INT;
	
	{attribute 'pytmc' := '
		pv: GM:F:F1
		io: o
	'}
	FLOW1 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:F:F2
		io: o
	'}
	FLOW2 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:P:P1
		io: o
	'}
	PRES1 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD1
		io: o
	'}
	RTD1 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD2
		io: o
	'}
	RTD2 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD3
		io: o
	'}
	RTD3 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD4
		io: o
	'}
	RTD4 : LREAL := 0.00;
	
		{attribute 'pytmc' := '
		pv: GM:T:RTD5
		io: o
	'}
	RTD5 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD6
		io: o
	'}
	RTD6 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD7
		io: o
	'}
	RTD7 : LREAL := 0.00;
	
	{attribute 'pytmc' := '
		pv: GM:T:RTD8
		io: o
	'}
	RTD8 : LREAL := 0.00;
	
	// Extra Mirror Pitch and Grating Pitch Encoders:
	{attribute 'TcLinkTo' := '.Count:=TIIB[m_pi_up_dwn_e]^FB Inputs Channel 1^Position'}	
	mpi_upe  AT %I*:  ST_RenishawAbsEnc := (Ref:=0);
	{attribute 'TcLinkTo' := '.Count:=TIIB[g_pi_up_dwn_e]^FB Inputs Channel 1^Position'}
	gpi_upe  AT %I*:  ST_RenishawAbsEnc := (Ref:=0);

	{attribute 'pytmc' := '
		pv: GM:m:pi:enc2
		io: o
	'}
	mpi_upeurad : LREAL;
	{attribute 'pytmc' := '
		pv: GM:g:pi:enc2
		io: o
	'}
	gpi_upeurad : LREAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// M1K2
M1K2.fbRunHOMS(stYup:=M1,
               stYdwn:=M2,
               stXup:=M3,
               stXdwn:=M4,
               stPitch:=M5,
	           nYupEncRef:=GVL_M1K2_Constants.nYLEFT_ENC_REF,
               nYdwnEncRef:=GVL_M1K2_Constants.nYRIGHT_ENC_REF,
               nXupEncRef:=GVL_M1K2_Constants.nXUP_ENC_REF,
               nXdwnEncRef:=GVL_M1K2_Constants.nXDWN_ENC_REF,
			   bExecuteCoupleY:=M1K2.bExecuteCoupleY,
               bExecuteCoupleX:=M1K2.bExecuteCoupleX,
			   bExecuteDecoupleY:=M1K2.bExecuteDecoupleY,
               bExecuteDecoupleX:=M1K2.bExecuteDecoupleX,
               bGantryAlreadyCoupledY=>M1K2.bGantryAlreadyCoupledY,
               bGantryAlreadyCoupledX=>M1K2.bGantryAlreadyCoupledX,
               nCurrGantryY=>M1K2.nCurrGantryY,
               nCurrGantryX=>M1K2.nCurrGantryX);

// Convert nCurrGantry to um (smaller number) to read out in epics
M1K2.fCurrGantryY_um := LINT_TO_REAL(M1K2.nCurrGantryY) / 1000.0;
M1K2.fCurrGantryX_um := LINT_TO_REAL(M1K2.nCurrGantryX) / 1000.0;

// FB_MotionStage's for non-piezo axes
fbMotionStage_m1(stMotionStage:=M1);
fbMotionStage_m2(stMotionStage:=M2);
fbMotionStage_m3(stMotionStage:=M3);
fbMotionStage_m4(stMotionStage:=M4);

// Calculate Pitch RMS Error:
fbYRMSErrorM1K2(stMotionStage:=M1,
	            fMaxRMSError=>fMaxYRMSErrorM1K2,
				fMinRMSError=>fMinYRMSErrorM1K2);

fbXRMSErrorM1K2(stMotionStage:=M3,
	            fMaxRMSError=>fMaxXRMSErrorM1K2,
				fMinRMSError=>fMinXRMSErrorM1K2);

fbPitchRMSErrorM1K2(stMotionStage:=M5,
	                fMaxRMSError=>fMaxPitchRMSErrorM1K2,
					fMinRMSError=>fMinPitchRMSErrorM1K2);

(*
// Pitch Control
fbM1K2PitchControl(Pitch:=GVL_M1K2.M1K2_Pitch,
				   Stepper:=M5,
				   lrCurrentSetpoint:=M5.fPosition,
                   q_bDone=>bM1K2PitchDone,
                   q_bBusy=>bM1K2PitchBusy);
// When STO hit, need to reset SP
IF NOT M5.bHardwareEnable THEN
	M5.fPosition := M5.stAxisStatus.fActPosition;
END_IF
*)
// 3-15-20: Having issues with pitch control on new Axilon systems
fbMotionStage_m5(stMotionStage:=M5);

// GM
// STO Interlock
M6.bHardwareEnable := bGMSTO1 AND bGMSTO2;
M7.bHardwareEnable := bGMSTO1 AND bGMSTO2;
M8.bHardwareEnable := bGMSTO1 AND bGMSTO2;
M9.bHardwareEnable := bGMSTO1 AND bGMSTO2;
M10.bHardwareEnable := bGMSTO1 AND bGMSTO2;
M11.bHardwareEnable := bGMSTO1 AND bGMSTO2;

// Screwdriver Rotation Has No Limits:
M11.bLimitForwardEnable := TRUE;
M11.bLimitBackwardEnable := TRUE;

// FB_MotionStage Control
fbMotionStage_m6(stMotionStage:=M6);
fbMotionStage_m7(stMotionStage:=M7);
fbMotionStage_m8(stMotionStage:=M8);
fbMotionStage_m9(stMotionStage:=M9);
fbMotionStage_m10(stMotionStage:=M10);
fbMotionStage_m11(stMotionStage:=M11);

// Flow and RTD Sensors
FLOW1 := INT_TO_LREAL(flow_1)/32767*4;
FLOW2 := INT_TO_LREAL(flow_2)/32767*4;
PRES1 := INT_TO_LREAL(pres_1)/32767*2;
RTD1 := INT_TO_LREAL(rtd_01)/100;
RTD2 := INT_TO_LREAL(rtd_02)/100;
RTD3 := INT_TO_LREAL(rtd_03)/100;
RTD4 := INT_TO_LREAL(rtd_04)/100;
RTD5 := INT_TO_LREAL(rtd_05)/100;
RTD6 := INT_TO_LREAL(rtd_06)/100;
RTD7 := INT_TO_LREAL(rtd_07)/100;
RTD8 := INT_TO_LREAL(rtd_08)/100;

// Extra Mirror Pitch and Grating Pitch Encoders:
mpi_upeurad := ULINT_TO_LREAL(mpi_upe.Count)*0.004505;
gpi_upeurad := ULINT_TO_LREAL(gpi_upe.Count)*0.0066667;]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>